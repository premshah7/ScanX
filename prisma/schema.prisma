generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int        @id @default(autoincrement())
  name        String
  email       String     @unique
  password    String
  phoneNumber String?    @unique
  username    String?    @unique // NEW: For Guest Login without Phone
  role        Role
  createdAt   DateTime   @default(now())
  status      UserStatus @default(PENDING)
  faculty     Faculty?
  student     Student?
  // managedEvents Subject[]  @relation("EventManagers")
}

enum Role {
  ADMIN
  FACULTY
  STUDENT
  GUEST
}

enum UserStatus {
  PENDING
  APPROVED
  REJECTED
}

model Otp {
  id        Int      @id @default(autoincrement())
  phone     String   @unique
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())
  attempts  Int      @default(0)
}

model Student {
  id                     Int            @id @default(autoincrement())
  userId                 Int            @unique
  rollNumber             String         @unique
  enrollmentNo           String         @unique
  deviceHash             String?
  isDeviceResetRequested Boolean        @default(false)
  batchId                Int?
  semester               Int            @default(1)
  deviceId               String?
  attendances            Attendance[]
  ownedProxyAttempts     ProxyAttempt[] @relation("DeviceOwner")
  proxyAttempts          ProxyAttempt[]
  batch                  Batch?         @relation(fields: [batchId], references: [id])
  user                   User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  subjects               Subject[]      @relation("StudentToSubject")
  guestDetails           Json? // Stores dynamic registration data (e.g., Company, Designation)

  @@index([deviceHash])
  @@index([deviceId])
}

model Faculty {
  id       Int       @id @default(autoincrement())
  userId   Int       @unique
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  subjects Subject[]
  // events   Subject[] @relation("EventOrganizers")
  batches  Batch[]   @relation("BatchToFaculty")
}

model Batch {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  subjectId Int?
  subject   Subject?  @relation(fields: [subjectId], references: [id])
  students  Student[]
  faculties Faculty[] @relation("BatchToFaculty")
  sessions  Session[] @relation("BatchToSession")
}

model Subject {
  id            Int       @id @default(autoincrement())
  name          String
  facultyId     Int?
  totalStudents Int       @default(60)
  batches       Batch[]
  sessions      Session[]
  faculty       Faculty?  @relation(fields: [facultyId], references: [id], onDelete: Cascade)
  // organizers         Faculty[] @relation("EventOrganizers")
  // managers           User[]    @relation("EventManagers") // NEW: Users (Faculty or Organizers) who manage the event
  students      Student[] @relation("StudentToSubject")
  // type               String    @default("SUBJECT") // "SUBJECT" or "EVENT"
  // slug               String?   @unique
  // description        String?
  // registrationConfig Json?
}

model Session {
  id            Int            @id @default(autoincrement())
  subjectId     Int
  isActive      Boolean        @default(true)
  startTime     DateTime       @default(now())
  endTime       DateTime?
  attendances   Attendance[]
  proxyAttempts ProxyAttempt[]
  subject       Subject        @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  batches       Batch[]        @relation("BatchToSession")
}

model Attendance {
  id        Int      @id @default(autoincrement())
  studentId Int
  sessionId Int
  timestamp DateTime @default(now())
  userAgent String?
  ipAddress String?
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([studentId, sessionId])
  @@index([sessionId])
}

model ProxyAttempt {
  id            Int      @id @default(autoincrement())
  studentId     Int
  sessionId     Int
  attemptedHash String
  timestamp     DateTime @default(now())
  deviceOwnerId Int?
  deviceOwner   Student? @relation("DeviceOwner", fields: [deviceOwnerId], references: [id])
  session       Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  student       Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
}

model SystemSettings {
  id               Int     @id @default(autoincrement())
  allowedIpPrefix  String  @default("")
  isIpCheckEnabled Boolean @default(false)
}
